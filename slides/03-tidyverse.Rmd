---
title: "The _Tidyverse_"
subtitle: "Data Science with R &#183; Summer 2021"
author: "Uli Niemann"
session: 03
institute: "Knowledge Management & Discovery Lab"
# date: "2016/12/12 (updated: `r Sys.Date()`)"
output:
  xaringan::moon_reader:
    css: ["default", "assets/css/my-theme.css", "assets/css/my-fonts.css"]
    seal: false # custom title slide
    lib_dir: libs
    nature:
      # highlightStyle: solarized-light
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: true
      ratio: "16:9"
params:
  url: "https://brain.cs.uni-magdeburg.de/kmd/DataSciR/"
---

```{r setup, include=FALSE}
source("global-slide-settings.R", local = knitr::knit_global(), encoding = "UTF-8")

# directory of generated figures
knitr::opts_chunk$set(fig.path = "figures/_gen/03/")
# directory of included figures
fig_path <- "figures/"

xaringanExtra::use_panelset()
xaringanExtra::use_tile_view()
```

```{r title-slide, child="title-slide.Rmd"}
```

---

name: motivation

## Why is (base) `R` hard to learn?

`R` has some idiosyncrasies that make it hard for learners who are used to other programming languages, e.g.:

.pull-left60[

- unhelpful help `?print`
- too many functions `colnames()`, `names()`
- inconsistent names `read.csv()`, `load()`, `readRDS()`
- clumsy console output `print(iris)`
- high flexibility (_is this bad?_)
- too many ways to select variables: `df$x`, `df$"x"`, `df[,"x"]`, or `df[[1]]`

]

.pull-right40[

```{r unhelpful-help, echo=FALSE, out.width="100%"}
knitr::include_graphics(file.path(fig_path, "03-unhelpful_help.png"))
```

&#x2753; _"invisibly"?_  
&#x2753; _"generic function"?_  
&#x2753; _"class"?_ 

]

.footnote[

See a more comprehensive list:  
Robert A. Muenchen. ["Why R is Hard to Learn"](http://r4stats.com/articles/why-r-is-hard-to-learn/). r4stats.com. Accessed 19.07.2018.

]

---

## Base `R` vs. tidyverse code

.pull-left[

&#x1F914; _"What does this base `R` code?"_

```{r aggregate}
aggregate(iris[, "Sepal.Length"], 
          list(Species = iris[, "Species"]), 
          mean)
```
{{content}}

]

--

&#x2753; _"What are the square brackets [ for?"_ &longrightarrow; They are used for subsetting a data frame.
{{content}}

--

&#x2753; _"What is list()?"_ &longrightarrow; It's a type of R object.
{{content}}

--

&#x2753; _"Why is the mean() function seemingly applied without argument?"_ &longrightarrow; It is being passed to the subsets of the data frame.
{{content}}

--

&#x2753; _"In the second line, why does the first "Species" does not need to be quoted, but the second "Species" does?"_ ...

--

.pull-right[

&#x1F60E; **tidyverse** equivalent:

```{r dplyr-aggregate, message=FALSE}
library(dplyr)
group_by(iris, Species) %>% 
	summarize(avg_sl = mean(Sepal.Length))
```

]

---

name: tidyverse-packages

## The Tidyverse

.pull-left[

```{r tidyverse-hex, echo=FALSE, out.width="100%"}
knitr::include_graphics(file.path(fig_path, "03-tidyverse.png"))
```

]

.pull-right[

Quote from the [Tidyverse website](https://www.tidyverse.org/):

.content-box-gray[

.font110[

"**R packages for data science.** The tidyverse is an **opinionated collection of R packages designed for data science**. All packages share an underlying **design philosophy, grammar, and data structures**."

]


]

&rarr; collection of open-source `R` packages mainly for data wrangling and visualization  
&rarr; shared conventions and common APIs across all Tidyverse packages

]

---

## Installation

```{r install-and-load-tidyverse, eval = FALSE}
# Install all Tidyverse packages
install.packages("tidyverse")

# Attach core packages
library(tidyverse)
```

The meta-package [`tidyverse`](https://www.tidyverse.org/packages/) contains `r length(tidyverse::tidyverse_packages(include_self = FALSE))` packages. 
When running `library(tidyverse)`, only the **core** tidyverse packages 
become available in your current `R` session. The core packages are:

.pull-left60[

**Core-Packages**:

- `ggplot2`: creation of graphics
- `dplyr`: data wrangling
- `tidyr`: data reshaping
- `readr`: import of flat data files, e.g. csv
- `tibble`: enhanced data frames
- `stringr`: string manipulation
- `forcats`: factor manipulation
- `purrr`: functions for working with list columns

]

.pull-right40[

```{r tidyverse-overview, echo=FALSE, out.width="100%"}
knitr::include_graphics(file.path(fig_path, "03-tidyverse_overview.png"))
```

.footnote[
.content-box-purple[

Figure source: Joseph Rickert. ["What is the tidyverse?"](https://rviews.rstudio.com/2017/06/08/what-is-the-tidyverse/). R Views. Accessed 13.07.2019.

]
]


]

---

name: dplyr
class: center, middle, inverse

```{r dplyr-logo, echo=FALSE, out.width="250px"}
knitr::include_graphics(file.path(fig_path, "03-dplyr.png"))
```

---


## Data wrangling with `dplyr` &#x1F6E0;&#xFE0F;

.pull-left70[

&#x1F914; _"What can I do with `dplyr`?"_

- get an overview of a tibble with `glimpse()`
- select a subset of columns with `select()`
- filter a subset of rows with `filter()`
- add new or change existing columns with `mutate()`
- pick a subset of rows with `slice()`
- reorder rows with `arrange()`
- group rows by a grouping column with `group_by()`
- calculate a summary (per group) with `summarize()`
- join two distinct tibbles by a common column with `*join()`
- ... (and more)

**Consistent API design:**

- first argument of each of these **verbs** is a data frame
<!-- - subsequent arguments reference columns in _non-standard evaluation_ notation (no quotation marks) -->
- the output is (usually) also a data frame

]

.pull-right30[


```{r ref.label="dplyr-logo", echo=FALSE, out.width="100%"}
```

]


???

- tibble: "enhanced" data frame 

---

## Case study: customer bookings data

.pull-left60[

.content-box-gray[
The company behind a travel price aggregator website wants to analyze its booking data to optimize the website's usability and thus improve their customers' travel experience.

The data is organized into two files: 

- `bookings.csv`: hotel bookings
- `properties.csv`: hotel facilities

]

]

.pull-right40[

```{r expedia, echo=FALSE, out.width="100%"}
knitr::include_graphics(file.path(fig_path, "03-expedia.png"))
```

]

```{r load-tidyverse, message = TRUE}
library(tidyverse)
```

```{r load-bookings, message = TRUE}
bookings <- read_csv("../data/bookings.csv")
```


.font80[

[Data source](https://github.com/drsimonj/tidyverse_tutorial-useR2018/tree/master/data).

]

---

## Get an overview wit `glimpse()`

```{r glimpse}
glimpse(bookings)
```

---

## Select columns with `select()` &#x1F446;

.panelset[

.panel[.panel-name[Select one column]

.pull-left70[

Select the column `review_score`.

```{r select-1}
select(bookings, review_score)
```

]

.pull-right30[

```{r select-icon, echo=FALSE, out.width="100%"}
knitr::include_graphics(file.path(fig_path, "03-dplyr_select.png"))
```

]

.content-box-blue[

The output is **always** a `data.frame` or `tibble`, regardless of whether a single or multiple columns are selected. 

]

]
.panel[.panel-name[Select multiple columns]

.pull-left70[

Select multiple columns by specifying column names as additional arguments.

```{r select-2}
select(bookings, review_score, status)
```


]

.pull-right30[

```{r ref.label = "select-icon", echo=FALSE, out.width="100%"}
```

]

]

.panel[.panel-name[Exclude columns]

.pull-left70[

Negative selection: select all but specific columns using `-`.

```{r select-3}
select(bookings, -booker_id)
```


]

.pull-right30[

```{r ref.label = "select-icon", echo=FALSE, out.width="100%"}
```

]

]

]

---

## Helper functions for `select()`

**Helper functions** facilitate selecting multiple columns whose names satisfy a specific criterion.

.pull-left60[

Helper function            | Description
:------------------------- | :----------------------------
`contains("abc")`          | Names containing `"abc"`
`starts_with("abc")`       | Names starting with `"abc"`
`ends_with("abc")`         | Names ending with `"abc"`
`num_range("a", 1:3)`      | Names matching the numerical range `a1`, `a2`, `a3`
`any_of(c("ab", "c"))`     | Any of the names within a character vector
`all_of(c("ab", "c"))`     | All of the names within a character vector
`matches(".id")`           | Names matching the regular expr. `".id"`
`everything()`             | All (remaining) names
`last_col()`               | Last column

]

---

## Examples of `select()` with helper functions

<!-- .content-box-purple[ -->
<!-- ] -->

.panelset[

.panel[.panel-name[Combined helpers]

> _"Select all columns whose names either contain 'id' or end with 'night'."_

```{r select-helper-1}
select(bookings, contains("id"), ends_with("night"))
```

]

.panel[.panel-name[`any_of()`]

> _"Select any of the two columns `room_nights`, `this_column_is_not_there`."_

```{r select-helper-2}
select(bookings, any_of(c("room_nights", "this_column_is_not_there")))
```

]

.panel[.panel-name[`all_of()`]

> _"Select both columns `room_nights`, `this_column_is_not_there`."_

```{r select-helper-3, error=TRUE}
select(bookings, all_of(c("room_nights", "this_column_is_not_there")))
```

]

]

---

## Filter rows with `filter()`

.pull-left70[

Filter bookings which stayed, i.e., didn't cancel.

```{r filter-1}
filter(bookings, status == "stayed")
```

```{r filter-2, eval=FALSE}
# the same as:
filter(bookings, status != "cancelled")
```

]

.pull-right30[

```{r filter-icon, echo=FALSE, out.width="100%"}
knitr::include_graphics(file.path(fig_path, "03-dplyr_filter.png"))
```

]

---

## Filter rows with `filter()`

.pull-left70[

Combine multiple conditions with `&`.

```{r filter-3}
filter(
  bookings, 
  status == "stayed" & 
    !is.na(review_score) & 
    between(price_per_night, 90, 120)
)
```


]

.pull-right30[

```{r ref.label="filter-icon", echo=FALSE, out.width="100%"}
```

]

---

exclude: true
class: middle, exercise-blue

## Your turn `r (yt_counter <- yt_counter + 1)`

Create a new tibble `x` that 

- only contains the columns `room_nights` and `review_score`, and 
- only contains the bookings with a price per night of less than 80.

1. _...using base `R` functions only._
2. _...using the `dplyr` functions `select()` and `filter()`._

`r countdown::countdown(minutes = 3)`

---

## Sort rows with `arrange()`

```{r arrange-1}
arrange(bookings, price_per_night) # default: sort in ascending order
```


```{r arrange-2}
arrange(bookings, desc(price_per_night))
```

---

## Select rows by position with `slice()`

```{r slice-1}
x <- arrange(bookings, desc(review_score))
slice(x, 1:10)
```

---

## Chaining multiple operations &#x26D3;&#xFE0F;

`dplyr` code is very intuitive and expressive, but also quite verbose. 

&#x1F914; _"How to organize the code so that it remains readable even for a high number of operations?"_

--

> Example: For all bookers who didn't cancel their trip and checked in on a friday, we are interested in the 5 highest review scores. Only the columns `price_per_night` and `review_score` should be included in a new tibble which is sorted by `review_score` in descending order. 

---

## Chaining multiple operations &#x26D3;&#xFE0F;

.panelset[

.panel[.panel-name[Nesting]

Solution 1 (nesting): 

.pull-left70[

```{r chaining-1}
select(
  slice(
    arrange(
      filter(
        bookings, !status == "cancelled" & checkin_day == "fri"),
      desc(review_score)
    ),
    1:5
  ), 
  price_per_night, review_score
)
```

]

.pull-right30[

```{r matroshka, echo=FALSE}
knitr::include_graphics(file.path(fig_path, "03-Russian-Matroshka2.jpg")) 
```

]

]

.panel[.panel-name[Save & overwrite intermediate results]

Solution 2 (save and overwrite intermediate results):

```{r chaining-2}
x <- filter(bookings, !status == "cancelled" & checkin_day == "fri")
x <- arrange(x, review_score)
x <- slice(x, 1:5)
x <- select(x, price_per_night, review_score)
x
```

]
.panel[.panel-name[Save result of each operation as new object]

Solution 3 (save each intermediate results as new object):  

```{r chaining-3, eval=FALSE}
x1 <- filter(bookings, !status == "cancelled" & checkin_day == "fri")
x2 <- arrange(x1, desc(review_score))
x3 <- slice(x2, 1:5)
x4 <- select(x2, price_per_night, review_score)
x4
```

_There is a mistake in the above code. Can you spot it?_

]

]

???

S1:

- could you easily read the code after half a year from now?
- arrange is the last operation but is read first

S2:

- very hard to spot mistakes you introduced in one of the earlier steps
- interested in the 5 highest review scores: desc(review_score)

S3:

- 4th line -> ~x2~ &rarr; x3 
- copy-and-paste problems: even if you know you make these mistakes you still will make the mistakes
- naming is difficult: what happens if I want to insert another operations later between x1 and x2?

---

name: pipe

## The pipe operator `%>%`

.pull-left70[

- The **pipe operator** `%>%` is used to pass information from one operation to the next.
- Its main purpose is to **express a sequence of operations**.
- Using the pipe, a function's output becomes the first argument of the subsequent function.
- Thus, the pipe operator helps to write **code that is easy to read and understand**.

```{r pipe-1, eval=FALSE}
bookings %>%
  filter(!status == "cancelled" & checkin_day == "fri") %>%
  arrange(desc(review_score)) %>%
  slice(1:5) %>%
  select(price_per_night, review_score)
```

]

.pull-right30[

```{r magrittr-logo, echo=FALSE, out.width="90%"}
knitr::include_graphics(file.path(fig_path, "03-magrittr.png"))
```

]

> "From table `bookings`, filter all non-canceled bookings with check-in on a Friday  
> THEN sort by review score in descending order  
> THEN take the top-5 bookings  
> THEN return price per night and review score."

.font80[

- In RStudio, the shortcut for `%>%` is **Ctrl+â‡§Shift+M**.  
- Although the pipe operator is implemented in the package `magrittr`, we do not need to load this package explicitly when we have loaded `tidyverse`.

]

???

- `%>%`: chain a new dplyr operation
- `+`: add a new layer to a ggplot2 plot

---

exclude: true
class: middle, exercise-blue

## Your turn `r (yt_counter <- yt_counter + 1)`

`r countdown::countdown(minutes = 5)`

Use `%>%` to write a pipeline which extracts all bookings with Friday as check-in 
day while only returning the columns `property_id` and `status`. 

---

## Adding new columns with `mutate()` &#x2795;

Create a new column for the **total price** of a booking, which 
is the product of `price_per_night` and `room_nights`. 

.panelset[

.panel[.panel-name[`mutate()`]

```{r mutate-1}
bookings %>%
  mutate(total_price = price_per_night * room_nights)
```

.content-box-yellow[

Note that a new variable will be appended as the last column of the data frame.

]

]
.panel[.panel-name[`mutate() + select()`]

(Only show `price_per_night`, `room_nights`, `total_price`)

```{r mutate-2}
bookings %>%
  mutate(total_price = price_per_night * room_nights) %>%
  select(price_per_night, room_nights, total_price) 
```

]

.panel[.panel-name[`mutate(..., .before = ...)`]

(Insert the new column before `booker_id`.)

```{r mutate-3}
bookings %>%
  mutate(total_price = price_per_night * room_nights, .before = booker_id) 
```


]

.panel[.panel-name[`mutate(..., .after = ...)`]

(Insert the new column after the second column (`property_id`).)

```{r mutate-4}
bookings %>%
  mutate(total_price = price_per_night * room_nights, .after = 2) 
```


]

]

???

- Syntax: mutate(name of new variable = equation)

---

## Replacing existing columns with `mutate()` &#x2795;

Convert the column `property_id` from `character` into `factor`. 

```{r mutate-5}
bookings %>%
  mutate(property_id = as.factor(property_id))
```

---

exclude: true
class: middle, exercise-blue

## Your turn `r (yt_counter <- yt_counter + 1)`

`r countdown::countdown(minutes = 3)`

Write a pipeline which calculates the mean-centered `price_per_night` as new column 
names `centered_ppn`. The returned data frame should only contain this new column.

_You need `mutate()` and `select()`._

---

## `mutate(across(...))`

Apply a transformation to **multiple columns**.

.panelset[

.panel[.panel-name[Select columns by name]

> Transform columns whose names end with "id" to factor variables.

```{r mutate-across-1}
bookings %>%
  mutate(across(ends_with("id"), as.factor))
```

]

.panel[.panel-name[Select columns by logical condition]

> Transform all columns of type `character` to factor variables.

```{r mutate-across-2}
bookings %>%
  mutate(across(where(is.character), as.factor))
```

]

<!-- .panel[.panel-name[]] -->

]


<!-- https://www.youtube.com/watch?v=0229Uq2hkJo&list=PLNUVZZ6hfXX1tyUykCWShOKZdIB0TIhtM&index=18 -->

???

- `mutate_at()`: select one or more columns to apply a function on with `vars()` helper function
- `mutate_if()`: apply a function to columns that fulfill a condition
- `mutate_all()`: apply a function to all columns

---

exclude: true

## `mutate_at/if/all()`

```{r}
# Create new columns with suffix '_chr'
bookings %>%
  mutate_at(vars(ends_with("id")), list(chr = as.character)) # applies to booker_id and property_id
```

---

exclude: true

## `mutate_at/if/all()`

```{r}
# Convert all character variables to factors
bookings %>%
  mutate_if(is.character, as.factor) # applies to booker_id, checkin_day and status
```

???

- place holder: the placeholder `.` is the dynamic variable when using `mutate_at()` 
 and other functions in the tidyverse.

---

## Summarize many rows with `summarize()` &#x1F5DC;

.pull-left70[

`summarize()` (or `summarise()`) performs some kind of aggregation and returns a summary table with fewer rows and removes all columns that are irrelevant to the calculation. 

]

.pull-right30[

```{r, echo=FALSE, out.width="100%"}
knitr::include_graphics(file.path(fig_path, "03-dplyr_summarize.png"))
```

]

.panelset[

.panel[.panel-name[A single one-valued stat]

> What is the average review score over all bookings?

```{r summary-1}
bookings %>%
  summarize(review_score = mean(review_score, na.rm = TRUE))
```

(one row, one column)

]

.panel[.panel-name[Multiple n-valued stats]

> What is the total number of bookings, the number of bookings without review score, and the average review score over all bookings?

```{r summary-2}
bookings %>%
  summarize(n = n(), # Total no. of bookings
            n_miss = sum(is.na(review_score)), # No. of bookings w/o review score
            review_score = mean(review_score, na.rm = TRUE)) # Avg. review score
```

(one row, multiple columns)

]

.panel[.panel-name[Multiple n-valued stats]

> What is the price range over all bookings?

```{r summary-3}
bookings %>%
  summarize(statistic = c("min", "max"), value = range(price_per_night))
```

(multiple rows, multiple columns)

]

]

---

exclude: true
class: middle, exercise-blue

## Your turn `r (yt_counter <- yt_counter + 1)`

`r countdown::countdown(minutes = 8)`

Obtain a one-row summary tibble of the bookings data containing the following statistics:

- The number of rows (Hint: use the function `n()`)
- The number of `"stayed"` bookings
- The mean of the _total price_ (Hint: you have to compute the total price first)

The output tibble should contain three columns and just one row.

---

## Grouping with `group_by()`

`group_by()` lets us perform operations for each _group_ separately.

```{r group-by-0}
bookings %>%
  group_by(for_business) %>% #<<
  summarize(n = n(), review_avg = mean(review_score, na.rm = TRUE))
```

.footnote[

.content-box-gray[

Use `ungroup()` to undo the grouping. 

]

]

--

```{r group-by-1}
class(bookings)
```

```{r group-by-2}
bookings %>% group_by(for_business) %>% class()
```

---

exclude: true
class: middle, exercise-blue

## Your turn `r (yt_counter <- yt_counter + 1)`

`r countdown::countdown(minutes = 10)`

Write a pipeline that yields a tibble containing only the most expensive booking 
of each property. Return only the property id and the price of the most expensive booking.

You should get as many rows as there are unique properties:

```{r yt-n_distinct}
n_distinct(bookings$property_id) # convenience function for `length(unique(bookings$property_id))`
```

1. Calculate `price_total` using `mutate()`.
1. Group by `property_id` using `group_by()`.
1. Filter rows where the total price is equal to the maximum of the total price 
(for that property using `filter()`).
1. Select the columns `property_id` and `price_total` using `select()`.

---

## Group by multiple columns

```{r group-by-3}
# Average score by travel type and check-in day of the week
bookings %>%
  group_by(for_business, checkin_day) %>%
  summarize(mean_review = mean(review_score, na.rm = TRUE))
```

---

## Count the number of rows per group with `count()`

Syntax: 

```{r count-syntax, eval = FALSE}
bookings %>%
  count(x, y, ...)
```

...is a shortcut for...

```{r count-syntax-1, eval = FALSE}
bookings %>%
  group_by(x, y, ...) %>%
  summarize(n = n())
```

--

.pull-left[

```{r count-1}
bookings %>%
  count(for_business, status)
```

]

.pull-right[

```{r count-2, message = FALSE}
bookings %>%
  group_by(for_business, status) %>%
  summarize(n = n())
```

]

---

name: join
class: center, middle, inverse

## Combining multiple data frames

---

## Customer bookings data

> What is the number of bookings per destination (city)?

To answer this question, we have to combine the two data frames `bookings` and `properties`.

.panelset[

.panel[.panel-name[`bookings`]

```{r ref.label="load-bookings", eval = FALSE}

```

```{r show-bookings, echo = FALSE}
bookings
```

]

.panel[.panel-name[`properties`]

```{r load-properties}
properties <- read_csv("../data/properties.csv")
properties
```

]

<!-- .panel[.panel-name[]] -->
<!-- .panel[.panel-name[]] -->

]

---

## Joining data frames

.panelset[

.panel[.panel-name[Data]

Consider the following two toy data frames `x` and `y`:

<!-- > A mutating join allows you to combine variables from two tables.  -->
<!-- > It first matches observations by their keys, then copies across variables  -->
<!-- > from one table to the other. -- [R for Data Science: Mutating joins](http://r4ds.had.co.nz/relational-data.html#mutating-joins) -->

.pull-left60[

```{r join-toy-data}
(x <- tibble(id = c(1L, 2L, 3L), x = c("x1", "x2", "x3")))
(y <- tibble(id = c(1L, 2L, 4L), y = c("y1", "y2", "y4")))
```

]

.pull-right40[

```{r join, echo=FALSE, out.width="100%", fig.align="center"}
knitr::include_graphics(file.path(fig_path, "03-join_x.png"))
```

]

.font80[Source of the figures on this and the following slides: <https://github.com/gadenbuie/tidyexplain>]

]

.panel[.panel-name[Basic syntax]

Basic syntax:

```{r join-syntax, eval = FALSE}
***_join(df1, df2, by = "<ID>")
```

]

.panel[.panel-name[Inner]

.pull-left70[

Join two data frames `x` and `y`. 
The result is a data frame containing all rows from `x` with matching values in 
`y` for column `id` and all columns from `x` and `y`.

```{r inner-join}
inner_join(x, y, by = "id")
```

]

.pull-right30[

```{r ref.label="join", echo=FALSE, out.width="100%", fig.align="center"}
```

```{r inner-join-gif, echo=FALSE, out.width="100%", fig.align="center"}
knitr::include_graphics(file.path(fig_path, "03-inner-join.gif"))
```

]

]
.panel[.panel-name[Left]

.pull-left70[

Join two data frames `x` and `y`. 
The result is a data frame containing all rows from `x` and all columns from `x` and `y`. 
In rows where there are no matching values in `y` for column `id`, the values of the 
columns that are present only in `y` are set to `NA`.

```{r left-join}
left_join(x, y, by = "id")
```

]

.pull-right30[

```{r ref.label="join", echo=FALSE, out.width="100%", fig.align="center"}
```

```{r left-join-gif, echo=FALSE, out.width="100%", fig.align="center"}
knitr::include_graphics(file.path(fig_path, "03-left-join.gif"))
```

]

]
.panel[.panel-name[Left 2]

.pull-left70[

In case of multiple matches, **all** combinations of the matches are returned:

```{r left-join-2}
(y_extra <- bind_rows(y, tibble(id = 2L, y = "y5")))
```


```{r left-join-3}
left_join(x, y_extra, by = "id")
```

]

.pull-right30[

```{r ref.label="join", echo=FALSE, out.width="100%", fig.align="center"}
```

```{r left-join-extra-gif, echo=FALSE, out.width="100%", fig.align="center"}
knitr::include_graphics(file.path(fig_path, "03-left-join-extra.gif"))
```

]

]

.panel[.panel-name[Right]

.pull-left70[

Join two data frames `x` and `y`. 
The result is a data frame containing all rows from `y` and all columns from `x` and `y`. 
In rows where there are no matching values in `x` for column `id`, the values of the 
columns that are present only in `x` are set to `NA`.

```{r right-join}
right_join(x, y, by = "id")
```

]

.pull-right30[

```{r ref.label="join", echo=FALSE, out.width="100%", fig.align="center"}
```

```{r right-join-gif, echo=FALSE, out.width="100%", fig.align="center"}
knitr::include_graphics(file.path(fig_path, "03-right-join.gif"))
```

]

]
.panel[.panel-name[Full]

.pull-left70[

Join two data frames `x` and `y`. 
The result is a data frame containing all rows and all columns from `x` and `y`. 
In rows where there are no matching values for column `id`, the values of the 
columns from the other data frame are set to `NA`.

```{r full-join}
full_join(x, y, by = "id")
```

]

.pull-right30[

```{r ref.label="join", echo=FALSE, out.width="100%", fig.align="center"}
```

```{r full-join-gif, echo=FALSE, out.width="100%", fig.align="center"}
knitr::include_graphics(file.path(fig_path, "03-full-join.gif"))
```

]

]
.panel[.panel-name[Semi]

.pull-left70[

Return all rows and columns from `x` with matching rows in `y`. 

```{r semi-join}
semi_join(x, y, by = "id")
```

]

.pull-right30[

```{r ref.label="join", echo=FALSE, out.width="100%", fig.align="center"}
```

```{r semi-join-gif, echo=FALSE, out.width="100%", fig.align="center"}
knitr::include_graphics(file.path(fig_path, "03-semi-join.gif"))
```

]

]
.panel[.panel-name[Anti]

.pull-left70[

Return all rows and columns from `x` **without** matching rows in `y`. 

```{r anti-join}
anti_join(x, y, by = "id")
```

]

.pull-right30[

```{r ref.label="join", echo=FALSE, out.width="100%", fig.align="center"}
```

```{r anti-join-gif, echo=FALSE, out.width="100%", fig.align="center"}
knitr::include_graphics(file.path(fig_path, "03-anti-join.gif"))
```

]

]

]

???

- mutating join: combine variables from two tables matching observations based on an id variable
- filtering join: match observations like in mutating join, but mergin will affect observations, not columns 

---

exclude: true
class: middle, exercise-blue

## Your turn `r (yt_counter <- yt_counter + 1)`

`r countdown::countdown(minutes = 3)`

Calculate the number of bookings per city. 

Hint: Join the data frames `bookings` and `properties` and _count_ the number of rows per city.  

---

exclude: true

## Filtering joins

> Filtering joins match observations in the same way as mutating joins, 
but affect the observations, not the variables. (...) 
Semi-joins are useful for matching filtered summary tables back to the original 
rows. (...) Anti-joins are useful for diagnosing join mismatches -- [R for Data Science: Filtering Joins](http://r4ds.had.co.nz/relational-data.html#filtering-joins)

---

exclude: true

## Joining data frames

```{r, echo=FALSE, out.width="60%", fig.align="center"}
knitr::include_graphics(file.path(fig_path, "03-dplyr_combine.png"))
```

---

name: tidyr
class: center, middle, inverse

```{r tidyr-logo, echo=FALSE, out.width="250px"}
knitr::include_graphics(file.path(fig_path, "03-tidyr.png"))
```

---

class: bottom, right
background-image: url("figures/03-kriminalitaetsatlas-berlin.png")
background-size: contain

.pull-right[

.content-box-gray[

## Tidy and untidy data

.font80[

[Data source](https://www.govdata.de/web/guest/daten/-/details/kriminalitatsatlas-berlin)

]

]

]

---

## Data come in different shapes...

.panelset[

.panel[.panel-name[`table1`]

```{r tidyr-table1, echo=FALSE}
table1
```

]

.panel[.panel-name[`table2`]

```{r tidyr-table2, echo=FALSE}
table2
```

]

.panel[.panel-name[`table3`]

```{r tidyr-table3, echo=FALSE}
table3
```

]

.panel[.panel-name[`table4a` & `table4b`]

```{r tidyr-table4, echo=FALSE}
table4a
table4b
```

]

]

???

- table1: each row contains information for the combination of country and year
- table2: each row represents a combination of country, year and variable. The count column contains the values of cases and population in separate rows
- table3: similar to table1, each row represents a combination of country and year, but instead of having separate columns for cases and population, they are stored as a string separated by a slash character
- table 4: data is organized into two dfs; table4a contains data on cases, table4b on population; each row is a country, each column represents a year and the cells are the values of the table's variable for the combination of country and year

---


## Reshape data frames with [`tidyr`](https://tidyr.tidyverse.org/)

.pull-left[

The `tidyverse` inherits its name from the term **tidy data**. 
Tidy data refers to a specific standardized dataset structure.

Characteristics of tidy data:

1. Each **variable** must have its own column.
1. Each **observation** must have its own row.
1. Each **value** must have its own cell.

Many of the tidyverse functions require a _tidy_ data frame input. 
The `tidyr` package contains functions to reshape "messy" into tidy data frames. 

]

.pull-right[


```{r tidyr-long-wide, echo=FALSE, out.width="100%"}
knitr::include_graphics(file.path(fig_path, "03-tidyr_long_wide.png"))
```

]

.footnote[

Further reading:

- [R for Data Science: Tidy data](https://r4ds.had.co.nz/tidy-data.html)
- Function overview: RStudio's [Data import cheat sheet](https://github.com/rstudio/cheatsheets/raw/master/data-import.pdf)

]

???

from r4ds:

As a data scientist, you will encounter a lot of untidy data, eg., because
it is easier to enter data into a spreadsheet in untidy way

---

## `pivot_longer()` and `pivot_wider()`

`tidyr`'s two main functions are `pivot_longer()` and `pivot_wider()`. 

- `pivot_longer()` takes multiple columns and collapses them into **key-value pairs**.
- `pivot_wider()` takes two or more columns (i.e., a key-value pair) and spreads them into **multiple columns**. 


```{r tidyr-pivot, echo=FALSE, out.width="45%", fig.align="center"}
knitr::include_graphics(file.path(fig_path, "03-tidyr_pivot.png"))
```

---

## `pivot_longer()` and `pivot_wider()`

.content-box-blue[

.font90[

```{r wide}
(wide <- tibble(name = c("Alex","Ben","Cedric"), DataSciR = c(2.0,1.7,1.0), VisAnalytics = c(3.3,1.3,2.0)))
```

This data frame is in **wide** format: there are 3 variables (name of student, course name, grade), but only the student's name has its own column.

]

]


--

.pull-left[

.font90[

Use `pivot_longer()` to collapse the two course columns into key-value pairs `course` and `grade`.

```{r wide-to-long}
tidy <- wide %>%
  pivot_longer(cols = -name, 
    names_to = "course", values_to = "grade")
tidy
```

]

]

--

.pull-right[

.font90[

Use `pivot_wider()` to "unpivot" a data frame. It is useful when there are variables that form rows instead of columns.

```{r long-to-wide}
tidy %>%
  pivot_wider(names_from = course, 
              values_from = grade)
```

]

]

???

- quotes for new / non-existing columns; no quotes when referring to existing colums

---

## Reshaping from "long" to "wide"

.panelset[

.panel[.panel-name[Long data]

.content-box-blue[

Compute the number of bookings per city and day:

```{r long-wide}
day_order <- c("mon", "tue", "wed", "thu", "fri", "sat", "sun")
df <- bookings %>% inner_join(properties, by = "property_id")
checkin_count <- df %>%
  count(destination, checkin_day) %>%
  mutate(checkin_day = factor(checkin_day, levels = day_order))
checkin_count
```

]

]
.panel[.panel-name[Wide data]

&#x1F914; _"How can we create the following table from `checkin_count`?"_

```{r spread, echo=FALSE}
checkin_count %>%
  arrange(checkin_day) %>% #<<
  pivot_wider(names_from = checkin_day, values_from = n)
```

]
.panel[.panel-name[Code]

```{r checkin-count-wider}
checkin_count %>%
  pivot_wider(names_from = checkin_day, values_from = n)
```

`pivot_wider()` creates the new columns in the order the keys appear in the data. 
Hence, we can sort the rows by `checkin_day` to obtain a data frame with the day-of-week columns in the correct order.

]
.panel[.panel-name[Wide data with correct order]

Arrange by `checkin_day` before reshaping the data frame into wide format:

```{r ref.label='spread'}
```

]

.panel[.panel-name[Undo]

.pull-left[

Bring the data back into long format:

```{r longer-1}
checkin_count %>%
  pivot_wider(names_from = checkin_day, 
              values_from = n) %>%
  pivot_longer(cols = c(mon, tue, wed, thu, #<<
                        fri, sat, sun), #<<
               names_to = "checkin_day",
               values_to = "n")
```

]

.pull-right[

Alternative variables selection:

```{r longer-2}
checkin_count %>%
  pivot_wider(names_from = checkin_day, 
              values_from = n) %>%
  pivot_longer(cols = -destination, #<<
               names_to = "checkin_day",
               values_to = "n")
```

]

]

]

???

- join bookings and properties
- count the number of bookings per city and check-in day of the week
- convert checkin_day from character to factor variable

---

exclude: true
class: middle, exercise-blue

## Your turn `r (yt_counter <- yt_counter + 1)`

`r countdown::countdown(minutes = 10)`

### Do properties appeal to business travellers and tourists alike?

- Convert the column `for_business` to a factor with the levels `"business"` and `"tourist"`.
- For each property, calculate the average review score given by business travelers and tourists.
- Then, calculate the average review score difference between business travelers and tourists. 

---

## `separate()`

```{r properties-head}
properties %>% head()
```

Have a look at the `facilities` column. It indicates the availability of various facilities in the accommodation.

---

## `separate()`

`separate()` splits up two or more variables that are clumped together in one column.

```{r separate, warning = TRUE}
properties %>%
  # Split `facilities` by `,` into multiple columns.
  separate(facilities, into = paste0("facility_", 1:9), sep = ",") %>%
  head(5)
```

We get a warning because the number of facilities differ across properties. The maximum number of facilities is 9. If a property has less than 9 facilities, the remaining columns are filled with `NA`.

--

.content-box-gray[

.font80[

&#x2705; `unite()` is the inverse function of `separate()` and combines multiple variables into one. 
For example, this operation could be useful for combining day, month and year columns into one date column. 

]

]

---

## Nesting tables

Common data structures are **hierarchical**, e.g. patient-centric data with repeat observations.

**Nesting** allows to store collapsed data frames and simplifies data management.

First, reshape `properties` into a tidy format:

```{r properties-long}
tp <- properties %>%
  separate(facilities, into = paste0("facility_", 1:9), sep = ",") %>%
  pivot_longer(cols = starts_with("facility_"), names_to = "facility_nr", values_to = "facility")
head(tp)
```

Now, the data frame contains a lot of duplicate information: 9x destination, property type and number of rooms for each property id.

---

## Nesting tables

Use `nest()` to create a nested data frame. 
The nested data frame contains a column `facilities` which is a **list of data frames**:

```{r nest-1}
nested_tp <- tp %>%
  nest(facilities = c(facility_nr, facility))
nested_tp
```

.footnote[

.content-box-gray[
Use `unnest()` to expand a list column, such that each element of the list becomes a row. 

]

]

---

## `drop_na()`

Some of the rows in the nested `facilities` column contain `NA`'s. How can we remove them?

.panelset[

.panel[.panel-name[Access nested data frame]

```{r nest-2}
nested_tp$facilities[1]
```

]

.panel[.panel-name[`drop_na()` on list columns]

The function `drop_na()` removes all rows with at least one missing value.

```{r drop-na-1}
nested_tp_wo_na <- nested_tp %>% 
  drop_na(facilities)
# Did it work?
nested_tp_wo_na$facilities[1]
```

]

.panel[.panel-name[`drop_na()` before nesting]

`dplyr`/`tidyr` functions don't work recursively.
Thus, we apply `drop_na()` before nesting.

```{r drop-na-2}
nested_without_missing <- tp %>%
  drop_na() %>% #<<
  nest(facilities = c(facility_nr, facility))
nested_without_missing$facilities[[1]]
```

]

]

---

exclude: true

## Bonus: `drop_na()`

Be aware that most `dplyr`/`tidyr` functions cannot deal with list columns. However, we can leverage the `map()` function from  the `purrr` package to apply the `drop_na()` function on each element of `facilities`.

```{r}
nested_tp_wo_na <- nested_tp %>%
  mutate(facilities = map(facilities, drop_na))
nested_tp_wo_na$facilities[1]
```

---

class: center, middle, inverse
name: readr

```{r readr-logo, echo=FALSE, out.width="250px"}
knitr::include_graphics(file.path(fig_path, "03-readr.png"))
```

---

## Data import

.pull-left70[

The first step of every data analysis project is to import one or more datasets. 
The tidyverse provides seven packages for the import of various data formats:

- `readr`: flat files (.csv, .tsv, ...)
- `DBI`: databases (SQLite, MySQL, PostgreSQL, MonetDB, ...)
- `haven`: foreign statistical formats (.sas, .sav, .dta)
- `jsonlite`: json files
- `readxl`: Excel files (.xls, .xlsx)
- `rvest`: websites (.html)
- `xml2`: xml files

]

.pull-right30[

```{r ref.label = "readr-logo", echo=FALSE, out.width="100%"}
```

]

.footnote[

.content-box-purple[

Function reference: RStudio's [Data import cheat sheet](https://github.com/rstudio/cheatsheets/raw/master/data-import.pdf)

]

]


---

## Data import: `bookings.csv` and `properties.csv`

.panelset[

.panel[.panel-name[`bookings.csv`]

```{r read-bookings, message = TRUE}
# library(readr) # readr is a core tidyverse package and hence doesn't need to be loaded separately. 
bookings <- read_csv("../data/bookings.csv")
head(bookings, 3)
```

]

.panel[.panel-name[`properties.csv`]

```{r read-properties}
properties <- read_csv("../data/properties.csv")
properties
```

]

]

---

## Comparison with Base R import functions

Base `R` already has functions for loading flat files, e.g. `read.csv()`, `read.delim()`.   

Advantages of the Tidyverse implementations include:

- higher speed
- ~~characters are not coerced to factors by default (see `stringsAsFactors` argument)~~  
(This is not the case anymore since `R` version 4.0)
- generates tibbles instead of data frames

---

name: tibble
class: center, middle, inverse

```{r tibble-logo, echo=FALSE, out.width="250px"}
knitr::include_graphics(file.path(fig_path, "03-tibble.png"))
```

---

## [Tibbles](https://tibble.tidyverse.org/) 

.pull-left80[

A tibble (class `tbl_df`) is "a modern reimagining" of the data frame.  
Advantages over traditional data frames include:

- improved print method that shows...
  - ...only the first 10 rows
  - ...all the columns that fit on screen + names of the remaining ones
  - ...column types
- more consistent subsetting
- less type coercion
- prohibits partial matching

]

.pull-right20[

```{r ref.label = "tibble-logo", echo=FALSE, out.width="100%"}
knitr::include_graphics(file.path(fig_path, "03-tibble.png"))
```

]

.font80[

.content-box-green[

Use `as_tibble()` to convert a data frame to a tibble.

]

]

???

- iris[, c(1,2)] returns data frame, but iris[, 1] returns a vector

---

## Tibble vs. data frame

.panelset[

.panel[.panel-name[Print `data.frame`]

```{r print-df-iris}
class(iris)
iris
```

]
.panel[.panel-name[Print `tbl_df`]

```{r print-tibble-iris}
as_tibble(iris)
```

]

.panel[.panel-name[Line width]

Tibbles adjust to the available line width!

```{r set-linewidth, echo=FALSE}
o <- getOption("width")
options(width = 50)
```

```{r print-tibble-iris-2}
as_tibble(iris)
```

```{r unset-linewidth, echo=FALSE}
options(width = o)
```

]
.panel[.panel-name[Build function]

```{r build-df}
df <- data.frame(
  `bad name` = 1:3, # syntactically invalid name because of SPACE
  x = rep(letters[1:2], length.out = 3) 
)
str(df)
```

Tibbles don't coerce character vectors to factors.

```{r}
ti <- tibble(
  `bad name` = 1:3, # no "auto repair" of invalid column name
  x = rep(letters[1:2], length.out = 3) 
)
str(ti)
```

]

.panel[.panel-name[Rowwise construction: `tribble()`]

Tibbles can also be created in a spreadsheet-like rowwise fashion:

```{r tribble}
tribble(
  ~x, ~y,
  1, "b",
  2, "a"
)
```

.content-box-blue[Use the tilde operator (`~`) to signify column names.]

]

]

---

exclude: true
name: purrr

## The `purrr` package &#x1F63B;

The `purrr` package provides a family of functions for applying some function to each element of a vector and saving the result.

.pull-left70[

`map*()` takes as arguments 1) an atomic vector or a list and 2) a function. 
It return a new vector of the **same length** as the input. The **type** of the vector is specified by the **suffix** of the `map*()` function. 

- `map()` returns a list
- `map_lgl()` returns a logical vector
- `map_int()` returns an integer vector
- `map_dbl()` returns a double vector
- `map_chr()` returns a character vector

Function reference: RStudio's [`purrr` cheat sheet](https://github.com/rstudio/cheatsheets/raw/master/purrr.pdf)


]

.pull-right30[

```{r, echo=FALSE, out.width="100%"}
knitr::include_graphics(file.path(fig_path, "03-purrr.png"))
```

]


.footnote[

The `*apply()` functions in base `R` (e.g. `apply()`, `lapply()`, `sapply()`, ...) have similar purposes, however they are inconsistent in their output and hence not recommended.

]

???

- problem with loops: you iterate over something, but it doesnt clearly convey a high level goal

---

exclude: true
class: middle, exercise-blue

## Your turn `r (yt_counter <- yt_counter + 1)`

`r countdown::countdown(minutes = 3)`

Actually, we don't need to store the property facilities as tibble, since the column `facility_nr` is redundant.

We change the `facilities` column to a list column, such that each element is a character vector of property facilities.

```{r}
properties_l <- properties %>% 
  mutate(facilities = strsplit(facilities, ","))
head(properties_l, 3)
```

Example:

```{r}
properties_l$facilities[[1]]
```

Add a column `n_features` to `properties` that contains the number of facilities.

Hint: Use the `map_*()` function that returns an integer vector. 

---

exclude: true

## Iteration over list columns

Perform a statistical test for each day of the week: _is there a difference 
in ratings between business travelers vs. non-business travelers?_

```{r, error=TRUE}
bookings %>% 
  group_by(checkin_day) %>% 
  summarise(t_test = t.test(review_score ~ for_business))
```

&#x1F914; _"Why does this code throw an error?"_

The return value of `t.test()` is of type `list`. When using `dplyr` operations 
like `mutate()`, 
we must explicitly declare that we want a list column.

```{r}
bookings %>% 
  group_by(checkin_day) %>% 
  summarize(t_test = list(t.test(review_score ~ for_business))) #<<
```

Extract the $p$-value from the `t_test` list column. 
Since we want a numeric column, we use `map_dbl()` to extract a double from 
a list.

```{r}
bookings %>% 
  group_by(checkin_day) %>% 
  summarize(t_test = list(t.test(review_score ~ for_business))) %>% 
  mutate(p_value = map_dbl(t_test, "p.value"))
```

---

exclude: true
class: middle, exercise-blue

## Your turn `r (yt_counter <- yt_counter + 1)`

`r countdown::countdown(minutes = 10)`

### _Which factors contribute to the average property review score?_

For **each city**, fit a **linear regression** model<sup>1</sup> to predict a property's **average review score** based on average price per night, number of bookings (stayed or canceled), and property type. Compare the quality of the three models using $R^2$.

Strategy:

1. Compute the summary statistics `avg_review` (average review score), 
`n_bookings` (number of bookings) and `avg_price` (average price per night) 
for each property and city.
2. For each city, fit a linear regression model (?`lm`) using the formula 
`avg_review ~ property_type + n_bookings + avg_price`. Save these models as new 
column `fit`.
3. Extract the $R^2$ value (`r.squared`) from `fit` using the appropriate `map_*` function.

.footnote[

[1] Remove properties with less than 2 non-missing review scores.

]

---

exclude: true

## Further materials

- Hadley Wickham and Garrett Grolemund. ["R for Data Science"](http://r4ds.had.co.nz/). O'Reilly, 2017. Chapter:
  - [Data transformation](http://r4ds.had.co.nz/transform.html)
  - [Tibbles](http://r4ds.had.co.nz/tibbles.html)
  - [Data import](http://r4ds.had.co.nz/data-import.html)
  - [Tidy data](http://r4ds.had.co.nz/tidy-data.html)
  - [Relational data](http://r4ds.had.co.nz/relational-data.html)
  - [Iteration](http://r4ds.had.co.nz/iteration.html)
- RStudio's cheat sheets (see next slides):
  - [Data Import (`readr + tidyr`)](https://github.com/rstudio/cheatsheets/raw/master/data-import.pdf)
  - [`dplyr`](https://github.com/rstudio/cheatsheets/raw/master/data-transformation.pdf)
  - [`purrr`](https://github.com/rstudio/cheatsheets/raw/master/purrr.pdf)

---

class: middle

## Very useful tidyverse packages we did not cover

```{r stringr-forcats-lubridate-logos, echo=FALSE, out.width="80%"}
knitr::include_graphics(file.path(fig_path, "03-stringr_forcats_lubridate.png"))
```

For an introduction, see the following chapters from  
Hadley Wickham and Garrett Grolemund. ["R for Data Science"](http://r4ds.had.co.nz/). O'Reilly, 2017.

- [Strings with stringr](https://r4ds.had.co.nz/strings.html)
- [Factors with forcats](https://r4ds.had.co.nz/factors.html)
- [Dates and Times with lubridate](https://r4ds.had.co.nz/dates-and-times.html)

---

```{r session-info, child="session_info.Rmd"}
```

---

```{r, child="last-slide.Rmd"}
```
